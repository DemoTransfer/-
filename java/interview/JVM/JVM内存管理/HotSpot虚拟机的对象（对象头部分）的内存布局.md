链接：
- 对象的内存布局：https://www.cnblogs.com/duanxz/p/4967042.html

深入理解Java虚拟机,在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域：

- 对象头(Header)
- 实例数据(Instance Data)
- 对齐填充(Padding)

## 32位

![image](https://github.com/Mein-Augenstern/MUYI/assets/34135120/e12f8c8c-c0cd-4a4f-ad61-c29f61eb5d27)

## 64位

![image](https://github.com/Mein-Augenstern/MUYI/assets/34135120/1b345654-47d3-467a-8199-a856f212bd35)

从上面的这张图里面可以看出，对象在内存中的结构主要包含以下几个部分：

- 对象头：

  - Mark Word(标记字段)：关于锁的信息。对象的Mark Word部分占4个字节/8个字节，表示对象的锁状态（比如轻量级锁的标记位，偏向锁标记位），另外还可以用来配合GC分代年龄、存放该对象的hashCode等。
  
  - Klass Pointer（Class对象指针）：Class对象指针的大小也是4个字节/8个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。
  
  - 数组长度：如果对象是数组类型，占用4个字节/8个字节，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。
  
- Instance Data（对象实际数据）：这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节。1字节 = 8bit

- padding data（对齐）：如果上面的数据所占用的空间不能被8整除，padding则占用空间凑齐使之能被8整除。被8整除在读取数据的时候会比较快

## 对象头

HotSpot虚拟机的对象头包括两部分信息,第一部分用于存储对象自身的运行时数据,如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等,这部分数据的长度在32位和64位的虚拟机(末开启压缩指针)中分别为32bit和64bit,官方称它为"Mark Word"。对象需要存储的运行时数据很多,其实已经超出了32位、64位Bitmap结构所能记录的限度,但是对象头信息是与对象自身定义的数据无关的额外存储成本,考虑到虚拟机的空间效率, Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息,它会根据对象的状态复用自己的存储空间,例如,在32位的HotSpot虚拟机中,如果对象处于未被锁定的状态下,那么Mark Word的32bit空间中的25bit用于存储对象哈希码, 4bit用于存储对象分代年龄, 2bit用于存储锁标志位, 1bit固定为0,而在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下对象的存储内容见下表。

![image](https://github.com/Mein-Augenstern/MUYI/assets/34135120/ac1e5bd9-6797-4cd0-8c30-0cf9f209afdf)

对象头的另外一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针,换句话说,查找对象的元数据信息并不一定要经过对象本身,这点将在2.3.3节讨论。另外,如果对象是一个Java数组,那在对象头中还必须有一块用于记录数组长度的数据,因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小,但是从数组的元数据中却无法确定数组的大小。

## 实例数据
接下来的实例数据部分是对象真正存储的有效信息,也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的,还是在子类中定义的,都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles, ints, shorts/chars, bytes/booleans. oops (Ordinary Object Pointers),从分配策略中可以看出,相同宽度的字段总是被分配到起。在满足这个前提条件的情况下,在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true (默认为true),那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

## 对齐填充
第三部分对齐填充并不是必然存在的,也没有特别的含义,它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍,换句话说,就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍),因此,当对象实例数据部分没有对齐时,就需要通过对齐填充来补全。
