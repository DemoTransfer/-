看在前面
====

> * <a href="https://review-notes.top/language/java-jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.html#%E6%96%B9%E6%B3%95%E5%8C%BA">运行时数据区域</a>

方法区
====

方法区是 JVM 提出的规范，而各个虚拟机的实现可以是不同的。关于方法区和永久代的关系描述：

> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

永久代&元空间
====

方法区是 JVM 提出的规范，而各个虚拟机的实现可以是不同的。
------

* 永久代则是 JDK8 前 Hotspot 虚拟机规范的实现（Java Heap 中）

* 元空间 JRockit、J9、JDK8 后 HotSpot 虚拟机的实现（在本地内存）

为什么 HotSpot 移除永久代？
------

* 移除永久代后，不会遇到永久代存在的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM 会自动根据类的元数据大小动态增加元空间的容量。

* 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

> 当你元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace

你可以使用 ```-XX：MaxMetaspaceSize``` 标志设置最大元空间大小，默认值为 ```unlimited```，这意味着它只受系统内存的限制。```-XX：MetaspaceSize``` 调整标志定义元空间的初始大小如果未指定此标志，则 ```Metaspace``` 将根据运行时的应用程序需求动态地重新调整大小。

* 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

* 这项改动是很有必要的，因为对永久代进行调优是很困难的。永久代中的元数据可能会随着每一次 Full GC 发生而进行移动。

HotSpot 虚拟机移除永久代改为元空间实现过程是？
------

* JDK 6，HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了

* JDK 7，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移出

* JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。




