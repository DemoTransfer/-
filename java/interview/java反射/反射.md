## 看在前面

* <a href="https://www.cnblogs.com/zhangchengzi/p/9723250.html">Java程序语言的后门-反射机制</a>

* <a href="https://www.jianshu.com/p/da21b3a59b47">Java中与泛型相关的接口术语定义</a>

## 一句话答案


Java 反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机制。

## 反射是什么?

反射是什么呢？其实是java程序语言的一种机制，我理解为是java的后门。在其他文章中给出的定义和解释都比较晦涩难懂，不如先看一下具体的代码，再去理解，这样就容易很多。

为了更好的理解反射机制，不得不提到类对象的概念，为了不与类和对象的概念搞混，我们就首先看一下类和对象的概念。相信你已经非常熟悉类和对象的概念了，那么我就简单的描述一下类与对象的概念：

* 类：一个或一组事物的抽象描述，例如狗是对狗狗这一组事物的抽象描述。

* 对象：具体的某一个事物，例如哈士奇等，也可以说是类的一个实例。

**那么类对象是什么呢**？

在java中一切皆对象。既然一切皆对象，当然类也是一种对象，那么类的对象类型是什么呢？是java.lang.Class，你也许在其他的地方见到过。不仅仅是有类对象，而且还有属性,方法和构造器都是对象，属性是```java.lang.reflect.Field```类的对象，方法是```java.lang.reflect.Method```类的对象，构造器是```java.lang.reflect.Constructor```类的对象。看来在java中确实是一切皆对象。

**那么类对象是从哪里来的，怎么创建的呢**？

我们都知道，想要得到一个类的对象，最基本的方法就是通过new关键字，去实例化一个对象。但类对象是一个特殊的对象，自然不能使用new关键字，翻看Class类的源码就可以证明：

```java
/*
 * 私有化构造方法，只有java 虚拟机才能创建类对象
 */
/*
 * Private constructor. Only the Java Virtual Machine creates Class objects.
 * This constructor is not used and prevents the default constructor being
 * generated.
 */
private Class(ClassLoader loader) {
	// Initialize final field for classLoader.  The initialization value of non-null
	// prevents future JIT optimizations from assuming this final field is null.
	classLoader = loader;
}
```

Class类中只有这一个私有的构造方法。其实类对象是java虚拟机（JVM）在加载class文件的时候自动在虚拟机内存中给我们创建的。

这里就涉及到了另外一个机制：**类加载机制**。

简单描述一下类加载机制：就是虚拟机将class文件加载到虚拟机内存中，最终形成可以被虚拟机直接使用的java类型。虚拟机会将class文件中的信息按照所需的存储格式放在方法区中，同时会在内存中（HotSpot是在堆内存中）实例化一个java.lang.Class类对象。

类加载机制是一个很复杂的过程，不是本篇文章的重点，就不展开来说。至少到这里我们已经知道了，类对象是由虚拟机创建的而且HotSpot虚拟机将类对象存放在堆内存中。

## Type及其子接口的来历

来自：https://www.jianshu.com/p/4cbe2e46e707

**泛型出现之前**

没有泛型的时候，只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。

GPT4.0重新描述这句话的含义为：在泛型出现之前，Java中所有的数据类型都是通过Class类来表示的。Class类是Java中的一个特殊类，它的对象可以代表任何一个Java类型，包括基本数据类型和引用数据类型。每一个Class对象都代表了一个具体的类型，比如int.class代表了int类型，String.class代表了String类型等。这些Class对象被称为原始类型（raw type），因为它们没有泛型信息。

**泛型出现之后**

泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型（ParameterizedType）、类型变量类型（TypeVariable）、泛型限定的参数化类型 (含通配符+通配符限定表达式)（WildcardType）、泛型数组类型（GenericArrayType）。

GPT4.0重新描述这句话的含义为：泛型的引入为Java的类型系统增加了更多的灵活性和表达能力。除了原始类型，也就是没有类型参数的类和接口（例如，List而不是List），泛型还引入了以下几种类型：
- 参数化类型（ParameterizedType）：这是使用泛型时最常见的情况，即类或接口后跟一对尖括号，里面包含一个或多个类型参数，例如List或Map<Integer, String>。
	- 就好比是给一个盒子加上标签，说明这个盒子里应该放什么东西。比如，你有一个装苹果的盒子，你在盒子上贴上一个标签写着“苹果”，这样就明确了这个盒子里只能放苹果。在Java中，这就像是你声明了一个List，这个List里只能放字符串。
	```java
	List<String> stringList = new ArrayList<String>();
	Map<Integer, String> map = new HashMap<Integer, String>();
	```
 
- 类型变量类型（TypeVariable）：这通常是在定义泛型类或泛型方法时出现的，它是代表一个类型参数的变量，例如在类定义中的T，如class MyClass中的T。
	- 这就像是给盒子定义了一个名字，让你可以在其他地方引用这个盒子。比如定义一个盒子叫做T，然后无论你需要什么类型的盒子，你都用T来代替，直到你明确告诉程序，T是苹果盒子还是香蕉盒子。
	```java
	// 在类定义中
	public class GenericClass<T> {
	    private T value;
	    
	    public T getValue() {
	        return value;
	    }
	    
	    public void setValue(T value) {
	        this.value = value;
	    }
	}
	
	// 在方法定义中
	public <T> T genericMethod(T param) {
	    return param;
	}
	```
   
- 泛型限定的参数化类型（WildcardType）：这涉及到使用通配符（?）作为类型参数，它可以进一步限定为上界（extends）或下界（super），表示该泛型类型被限定为某个特定类型的子类型或父类型。例如List<? extends Number>表示这个列表包含的类型是Number或其子类型。
	- 这一点就像是对盒子的内容做了一些额外的说明，比如你可以说这个盒子里可以放苹果，也可以放苹果的任何品种（如青苹果、红苹果等），或者说这个盒子可以放水果，但必须是类似苹果这样的水果。在Java中，这就像是使用了通配符，比如List<? extends Fruit>，意思是这个List可以放Fruit或者Fruit的任何子类，如苹果或香蕉。
	```java
	List<? extends Number> numbers = new ArrayList<Integer>(); // 上界通配符，可以存放Number及其子类
	List<? super Integer> integers = new ArrayList<Number>(); // 下界通配符，可以存放Integer及其父类
	```
 
- 泛型数组类型（GenericArrayType）：这表示元素类型为某个参数化类型或类型变量的数组，例如List[]是一个数组，其元素类型为List。
	- 这就好比你有很多个相同类型的盒子，现在你想把这些盒子放在一个大箱子里。在Java中，这就像声明了一个List[]，意思是你有一个数组，每一个元素都是可以放字符串的List。	
	```java
	// Java不允许直接创建泛型数组，但可以这样声明
	List<String>[] arrayOfStringLists;
	
	// 创建泛型数组需要通过Array.newInstance
	arrayOfStringLists = (List<String>[]) Array.newInstance(ArrayList.class, 10);
	```

总之，泛型的出现让Java的类型系统更加丰富和复杂，使得程序员可以创建更加通用和类型安全的代码。


## ParameterizedType

直观体感参照：https://www.cnblogs.com/Meiwah/p/10434893.html

第一种说法

> ParameterizedType就是参数化类型的意思，声明类型中带有“<>”的都是参数化类型，比如List<Integer>，Map<String,Long>

```java
getActualTypeArguments()返回Type[]，即“<>”里的参数，比如Map<String,Integer>

getRawType()返回Tpye，得到“<>”前面的类型，比如List<String>

getOwnerType()返回Type，O<T>.I<S>类型变量调用时会返回O<T>，比如Map.Entry<Long,Short>
```

第二种说法

> 这是在 java.lang.reflect 包中一个接口的名称，很多文章中把它翻译为“参数化类型”，我通过参阅多方资料发现其实这个接口就是对“泛型实例”的说明。所以在之后的文章中，我就把这个接口称之为“泛型实例”。
其实这个接口就是在说明一个带参数的类型，如：Collection<String>，Map<String,Object>等。这看似大家平常所说的泛型，但其实不然。我们大家平时所说的泛型是Collection<E>和Map<K,V>等，而ParameterizedType表示的是泛型（Collection<E>和Map<K,V>等）的一种实例（Collection<String>和Map<String,Object>）。


## TypeVariable


## GenericDeclaration


## GenericArrayType


## WildcardType

## 反射常用方法

### getGenericSuperclass()


先看一段代码

```JAVA

@SuppressWarnings({ "unchecked", "deprecation" })
private void init() {
	Class<T> entityClass = null;
	Class<?> c = getClass();
	Type type = c.getGenericSuperclass();

	if (type instanceof ParameterizedType) {
		Type[] parameterizedType = ((ParameterizedType) type)
				.getActualTypeArguments();
		entityClass = (Class<T>) parameterizedType[0];
	}

	// 进行扫注解，确定模板的输入输出文件名
	DataTemplate dataTemplate = entityClass
			.getAnnotation(DataTemplate.class);
	if (null != dataTemplate) {
		this.outputName = dataTemplate.output();
		if (NullOrEmpty.isNullOrEmpty(dataTemplate.template())) {
			this.templateName = entityClass.getName();
		} else {
			this.templateName = dataTemplate.template();
		}
	} else {
		this.outputName = entityClass.getName();
		this.templateName = entityClass.getName();
	}

	this.freeMarkerCfg = new Configuration();
	freeMarkerCfg.setObjectWrapper(new DefaultObjectWrapper());
	freeMarkerCfg.setDefaultEncoding(Charset.forName("UTF-8").name());

}
```

```JAVA
public class Person<T> {
 
}
```

```java

import java.lang.reflect.*;
 
public class Student  extends Person<Student>{
 
	@SuppressWarnings("unchecked")
	public static <T> void main(String[] args) {
		 Student st=new Student();
		 @SuppressWarnings("rawtypes")
		 Class clazz=st.getClass();
		 //getSuperclass()获得该类的父类
		 System.out.println(clazz.getSuperclass());
		 //getGenericSuperclass()获得带有泛型的父类
		 //Type是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型。
		 Type type=clazz.getGenericSuperclass();
		 System.out.println(type);
		 //ParameterizedType参数化类型，即泛型
		 ParameterizedType p=(ParameterizedType)type;
		 //getActualTypeArguments获取参数化类型的数组，泛型可能有多个
		 Class<T> c=(Class<T>) p.getActualTypeArguments()[0];
		 System.out.println(c.getName());
		 System.out.println(c);
	}
 
}
```
执行结果:

```java
class com.neteae.web.test.Person
com.neteae.web.test.Person<com.neteae.web.test.Student>
com.neteae.web.test.Student
class com.neteae.web.test.Student
```
