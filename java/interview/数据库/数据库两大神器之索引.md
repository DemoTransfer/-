看在前面
====

> * <a href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a>


* **掘金特邀作者 | 技术公众号：Java3 y**

* **文章导航：https://github.com/ZhongFuCheng3y/3y**

> 声明：如果没有说明具体的数据库和存储引擎，默认指的是MySQL中的InnoDB存储引擎

一、索引
====

在之前，我对索引有以下的认知：

* **索引可以加快数据库的检索速度**
* **表**经常进行```INSERT/UPDATE/DELETE```操作就不要建立索引了，换言之：**索引会降低插入、删除、修改等维护任务的速度。**
* 索引需要占**物理和数据空间。**
* 了解过索引的最左匹配原则
* 知道索引的分类：聚集索引和非聚集索引
* Mysql支持Hash索引和B+树索引两种

看起来好像啥都知道，但面试让你说的时候可能就GG了：

* 使用索引为什么可以加快数据库的检索速度啊？
* 为什么说索引会降低插入、删除、修改等维护任务的速度。
* 索引的最左匹配原则指的是什么？
* Hash索引和B+树索引有什么区别？主流的使用哪一个比较多？InnoDB存储都支持吗？
* 聚集索引和非聚集索引有什么区别？
* ......

1.1聊聊索引的基础知识
------

首先Mysql的基本存储结构是**页**(记录都存在页里边)：

![InnoDB页数据示意图一](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/InnoDB%E9%A1%B5%E6%95%B0%E6%8D%AE%E7%A4%BA%E6%84%8F%E5%9B%BE%E4%B8%80.png)

![InnoDB页数据示意图二](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/InnoDB%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE%E4%BA%8C.png)

* **各个数据页可以组成一个双向链表**
* **每个数据页中的记录又可以组成一个单向链表**

    * 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
    
    * 以其他列（非主键）作为搜索条件：只能从最小记录开始一次遍历单链表中的每条记录。

所以说，如果我们写

```sql
select * from user where indexname = 'xxx'
```
这样没有进行任何优化的sql语句，默认会这样做：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

很明显，在数据量很大的情况下这样查询会很慢！这样的时间复杂度为O(N);

1.2索引提高检索速度
------

索引做了些什么可以让我们查询加快速度呢？

其实就是**将无序的数据变成有序(相对)：**

![索引查询过程一](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%B8%80.png)

要找到id为8的记录简要步骤：

![索引查询过程二](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%BA%8C.png)

很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过“**目录**”就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）

其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

参考资料:

> <a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0">MySQL的索引</a>

1.3索引降低增删改的速度
------

**B+树**是**平衡树**的一种。

> 平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如果一棵普通的树在**极端**的情况下，是**能退化成链表**的(树的优点就不复存在了)

![树极端情况下退化为单链表](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/%E6%A0%91%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5%E4%B8%8B%E9%80%80%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8.jpeg)

B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的（本符合**矮矮胖胖(均衡)的结构**）【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。

* B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构。**
* **要维持平衡树，就必须做额外的工作。**正因为这些额外的工作**开销**，导致索引会降低增删改的速度

B+树删除和修改具体可参考：

> * <a href="https://www.cnblogs.com/wade-luffy/p/6292784.html">B+树介绍</a>

1.4哈希索引
------

除了B+树之外，还有一种常见的是哈希索引。

哈希索引就是采用一定的**哈希算法**，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可**立刻定位到相应的位置，速度非常快。**

* 本质上就是把**键值换算成新的哈希值**，根据这个**哈希值来定位。**

![哈希索引](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E4%B8%80.jpeg)

看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：

* 哈希索引也没办法利用索引完成**排序**
* 不支持最左匹配原则
* 在有大量重复键值情况下，哈希索引的效率也是极低的---->**哈希碰撞**问题
* 不支持范围查询

参考资料：

> * <a href="https://www.cnblogs.com/zengkefu/p/5647279.html">MySQL B+树索引和哈希索引的区别</a>

1.5InnoDB支持哈希索引吗？
------

主流的还是使用**B+树索引比较多**，对于哈希索引，**InnoDB是自适应哈希索引**的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！

![InnoDB是否支持哈希索引](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/InnoDB%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.jpeg)

参考资料：

> * <a href="https://blog.csdn.net/doctor_who2004/article/details/77414742">mysql InnoDB引擎支持hash索引吗</a>

1.6聚集和非聚集索引
------

简单概括：

* 聚集索引就是以**主键**创建的索引
* 非聚集索引就是以**非主键**创建的索引

区别：

* 聚集索引在叶子节点存储的是**表中的数据**
* 非聚集索引在叶子节点存储的是**主键和索引列**
* 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据。**(拿到主键再查找这个过程叫做回表)

**非聚集索引也叫做二级索引**，不用纠结那么多名词，将其等价就行了~

非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

* 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)

* **创建多个单列(非聚集)索引的时候，会生成多个索引树**(所以过多创建索引会占用磁盘空间)

![聚集和非聚集索引](https://github.com/DemoTransfer/demotransfer/blob/master/java/interview/picture/%E8%81%9A%E9%9B%86%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.jpeg)

在创建多列索引中也涉及到了一种特殊的索引-->**覆盖索引**

* 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值
* 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢
* 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作！

比如说：

* 现在我创建了索引```(username,age)```，在查询数据的时候：```select username , age from user where username = 'Java3y' and age = 20```。
* 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~
* 所以，能使用覆盖索引就尽量使用吧~

1.7索引最左匹配原则
------

最左匹配原则：

* 索引可以简单如一个列```(a)```，也可以复杂如多个列```(a, b, c, d)```，即联合索引。
* 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询```(>、<、between、like```左匹配)等就**不能进一步匹配**了，，后续退化为线性查找。
* 因此，**列的排列顺序决定了可命中索引的列数。**

例子：

* 如有索引```(a, b, c, d)```，查询条件```a = 1 and b = 2 and c > 3 and d = 4```，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是相等的情况，不能是范围匹配)

再配合个例子：<a href="https://www.zhihu.com/question/52536048">MySQL索引，最左前缀匹配的内部原理是什么？</a>

我知道最左前缀匹配这回事，但是不知道为什么，比如：

1. 建了一个索引：(a, b, c)
2. 执行下面两个SQL。

```java
SELECT * FROM table WHERE a = 1 AND c = 3; // c不走索引
SELECT * FROM table WHERE a = 1 AND b < 2 AND c = 3; // c不走索引
```

问题：我知道由于最左前缀匹配，c不走索引，但是不知道为什么，请问内部原理是什么？

因为根据a->b->c排序的时候，a相同的值都放在一起，c相同的值都不在一起，所以没办法走索引。

a-b-c这样的索引当然（在逻辑上等同于）是先找a，然后在范围里面找b，再找c。上述问题里的c会分散在很多个b里面，当然没办法走索引。

1.8=、in自动优化顺序
------

**不需要考虑=、in等的顺序**，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：

* 如有索引```(a, b, c, d)```，查询条件```c > 3 and b = 2 and a = 1 and d < 4```与```a = 1 and c > 3 and b = 2 and d < 4```等顺序都是可以的，MySQL会自动优化为```a = 1 and b = 2 and c > 3 and d < 4，```依次命中a、b、c。

1.9索引总结
------

索引在数据库中是一个**非常**重要的知识点！上面谈的其实就是索引**最基本**的东西，要创建出好的索引要顾及到很多的方面：

* 1、**最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询```（>,<,BETWEEN,LIKE）```就停止匹配。
* 2、**尽量选择区分度高的列作为索引**，区分度的公式是 ```COUNT(DISTINCT col) / COUNT(*)```。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
* 3、**索引列不能参与计算，尽量保持列“干净”**。比如，```FROM_UNIXTIME(create_time) = '2016-06-06'```就不能使用索引，原因很简单，**B+树中存储的都是数据表中的字段值**，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ：```create_time = UNIX_TIMESTAMP('2016-06-06')。```
* 4、尽可能的**扩展索引**，不要新建索引，比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
* 5、单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，**MySQL只能使用一个索引**，会从多个单列索引中选择一个限制最为严格的索引。两者之间并无关联。

参考资料：

> * <a href="https://zhuanlan.zhihu.com/p/23624390">深入浅出数据库索引原理</a>
> * <a href="https://blog.csdn.net/mysteryhaohao/article/details/51719871">MySQL学习之——索引(普通索引、唯一索引、全文索引、索引匹配原则、索引命中等)</a>
> * <a href="https://monkeysayhi.github.io/2018/03/06/%E6%B5%85%E8%B0%88MySQL%E7%9A%84B%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">浅谈MySQL的B树索引与索引优化 </a>
