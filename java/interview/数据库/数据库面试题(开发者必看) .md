看在前面
====

> * <a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483856&idx=1&sn=ea1c06f0852d3bca3b98b64d8589598e&chksm=ebd740d1dca0c9c77ed1bb07a96bd0fbe147a13515797cf71597de821dbe3357e3eef5f741dc&scene=21###wechat_redirect">数据库面试题(开发者必看) </a>


* **掘金特邀作者 | 技术公众号：Java3 y**

* **文章导航：https://github.com/ZhongFuCheng3y/3y**

数据库常见面试题（开发者篇）
====

![SQL相关]()

![SQL知识点]()

什么是存储过程？有哪些优缺点？
====

存储过程就像我们编程语言中的函数一样，封装了我们的代码（```PLSQL、T-SQL```）

存储过程的优点：

* 能够将代码封装起来

* 保存在数据库之中

* 让编程语言进行调用

* 存储过程是一个预编译的代码块，执行效率比较高

* 一个存储过程代替大量T_SQL语句，可以降低网络通信量，提高通信速率

存储过程的缺点：

* 每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）

* 业务逻辑放在数据库，难以迭代

三个范式是什么
====

> 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

> 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 

> 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y

上面的文字我们肯定是看不懂的，也不愿意看下去的。接下来我就来总结一下：

* 首先要明确的是：**满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式**。

* 第一范式：**字段是最小的单元不可再分**
    
    * 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的
    
* 第二范式：满足第一范式，**表中的字段必须完全依赖于全部主键而非部分主键**。

    * **其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，他们只需要依赖于主键，也就成了唯一的**
    
    * 学好为1024的同学，姓名为Java3y，年龄22岁。姓名和年龄字段都依赖着学号主键。
    
* 第三范式：满足第二范式，**非主键外的所有字段必须互补依赖**

    * 就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖
    
    * 比如，我们大学分了很多系（中文系、英语系、计算机系......），这个系别管理表信息有以下字段组成：系编号、系主任、系简介、系架构。那我们能不能在学生信息表中添加系编号、系主任、系简介、系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系（依赖到学生信息表了）！正确的做法是：学生表就只能增加一个系编号字段。
    
参考链接：

> * <a href="https://www.zhihu.com/question/24696366">如何理解关系型数据库的常见设计范式？</a>

> * <a href="https://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html">数据库范式那些事</a>

什么是视图？以及视图的使用场景有哪些？
====

视图是一种基于数据库表的一种**虚表**

* 视图是一种虚表

* 视图建立在已有表的基础上，视图赖以建立的这些表成为基表

* **向视图提供数据内容的语句为SELECT语句，可以将视图理解为存储起来的SELECT语句**

* 视图向用户提供基表数据的另一种表现形式

* 视图没有存储真正的数据，真正的数据还是存储在基表中

* 程序员虽然操作的是视图，但最终视图还会转成操作基表

* 一个基表可以有0个或者多个视图

有的时候，我们可能之关心一张数据表中的某些字段，而另外的一些人只关心同一张数据库的某些字段......

那么把全部的字段都显示给他们看，这是不合理的。

我们应该做到：**他们想看什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄漏出来...**

![数据库视图一]()

我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长......上面已经说了，**视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。那么我们使用的时候就会变得非常方便.....**

值得注意的是：**使用视图可以让我们专注于逻辑，但不提高查询效率**

drop、delete与truncate分别在什么场景之下使用？
====

我们来对比一下他们的区别：

**<h3>drop table</h3>**

 1. 属于DDL
 2. 不可回滚
 3. 不可待where
 4. 表内容和结构删除
 5. 删除速度快
 
**<h3>truncate table</h3>**

 6. 属于DDL
 7. 不可回滚
 8. 不可带where
 9. 表内容删除
 10. 删除速度快
 
**<h3>delete from</h3>**

 1. 属于DML
 2. 可会滚
 3. 可带where
 4. 表结构在，表内容要看where执行的情况
 5. 删除速度慢，需要逐行删除
 
注意：

* **不再需要一张表的时候，用drop**

* **想删除部分数据行的时候，用delete，并且带上where子句**

* **保留表而删除所有的数据用truncate**

索引是什么？有什么作用以及优缺点？
====

**<h3>什么是索引【index】</h3>**

 1. 是一种快速查询表中内容的机制，类似于新华字典的目录
 2. 运用在表中某个些字段上，但存储时，独立于表之外
 
索引表把数据变成是有序的......

![数据库面试-索引-知识点一]()

快速定位到硬盘中的数据文件......

![数据库面试-索引-知识点二]()

**<h3>rowid特点</h3>**

 1. 位于每个表中，但表面看不见，例如：desc emp是看不见的
 2. 只有在select中，显示出rowid，方可看见
 3. 它与每个表绑定在一起，表亡，该表的rowid亡，二张表rownum可以相同，但是rowid必须是唯一的
 4. rowid是18位大小写加数字混杂体，具备唯一性，并且待变该条记录在DBF文件中的位置
 5. rowid可以残念与=/like比较的，用''单引号将rowid的值包起来，区分大小写
 6. rowid是联系表与DBF文件的桥梁
 
**<h3>索引特点</h3>**
 
 1. 索引一旦建立，**Oracleguanine系统会对其进行自动维护**，而且由Oracle管理系统决定何时使用索引
 2. 用户不用在查询语句中指定使用哪个索引
 3. **在定义primary key或unique约束后系统自动在相应的列上创建索引**
 4. 用户也能按照自己的需求，对指定单个字段或多个字段，添加索引
 
需要注意的是：**Oracle是自动帮我们管理索引的，并且如果我们指定了primary key或者unique约束，系统会自动在对应的列上创建索引......**

**<h3>什么时候【要】创建索引</h3>**

 1. 表经常SELECT操作
 2. 表很大（记录超多），记录内容分布范围很广
 3. 列表经常在WHERE子句或者连接条件中出现
 
**<h3>什么时候【不要】创建索引</h3>**

 1. 表经常进行INSERT/UPDATE/DELETE操作
 2. 表很小（记录很少）
 3. 列表不经常作为连接条件或出现在WHERE子句中
 
**<h3>索引优缺点</h3>**

 1. 索引加快数据库的检索速度
 2. 索引降低了插入、删除、修改等维护任务的速度（虽然索引可以提高速度，但是他们也会导致数据库系统更新数据的性能下降，**因为大部分数据更新需要同事更新索引**）
 3. 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
 4. 索引需要栈物理和数据空间
 
**<h3>索引分类</h3>**

 1. **唯一索引**：唯一索引不允许两行数据具有相同的数据
 2. **主键索引**：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
 3. **聚合索引（Clustered）**：表中各行的物理顺序和键值的逻辑（索引）顺序相同，每个表只能有一个
 4. **非聚集索引（Non-clustered）**：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另外一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249
 
深入理解索引可以参考：

> * <a href="https://kb.cnblogs.com/page/45712/">漫谈数据库索引</a>

> * <a href="https://www.cnblogs.com/drizzlewithwind/p/5707058.html">索引类型</a>

什么是事务
====

事务简单来说：**一个Session中所进行所有的操作，要么同时成功，要么同时失败**

**<h3>ACID--数据库事务正确执行的四个要素</h3>**

* 包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

**一个支持事务（Transaction）中的数据库系统，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易**。

举个例子：**A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来一样【A账户的钱没变，B账户的钱也没变】。**

示例说明：

```java
// 我们来模拟A向B账号转账的场景
// A和B账户都有1000块，现在我让A账户向B账号转500块钱
// JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题

// A账户减去500块
String sql = "UPDATE a SET money=money-500 ";
preparedStatement = connection.prepareStatement(sql);
preparedStatement.executeUpdate();

// B账户多了500块
String sql2 = "UPDATE b SET money=money+500";
preparedStatement = connection.prepareStatement(sql2);
preparedStatement.executeUpdate();
```

从上面看，我们的确可以发现A向B转账，成功了。可是**如果A向B转账的过程中出现了问题呢？**下面模拟一下

```java
/A 账户减去500块
String sql = "UPDATE a SET money=money-500 ";
preparedStatement = connection.prepareStatement(sql);
preparedStatement.executeUpdate();

// 这里模拟出现问题
int a = 3 / 0;

String sql2 = "UPDATE b SET money=money+500";
preparedStatement = connection.prepareStatement(sql2);
preparedStatement.executeUpdate();
```

显然，上面**代码是会抛出异常的**，我们再来查询一下数据。**A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。**

我们可以通过事务来解决上面出现的问题

```java
// 开启事务,对数据的操作就不会立即生效。
connection.setAutoCommit(false);

// A账户减去500块
String sql = "UPDATE a SET money=money-500 ";
preparedStatement = connection.prepareStatement(sql);
preparedStatement.executeUpdate();

// 在转账过程中出现问题
int a = 3 / 0;

// B账户多500块
String sql2 = "UPDATE b SET money=money+500";
preparedStatement = connection.prepareStatement(sql2);
preparedStatement.executeUpdate();

// 如果程序能执行到这里，没有抛出异常，我们就提交数据
connection.commit();

// 关闭事务【自动提交】
connection.setAutoCommit(true);


} catch (SQLException e) {
try {
    // 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】
    connection.rollback();

    // 关闭事务【自动提交】
    connection.setAutoCommit(true);
} catch (SQLException e1) {
    e1.printStackTrace();
}
```

上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。

注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但**如果程序捕获到了异常，是需要在catch中显式回滚事务的**。

**<h3>事务隔离级别</h3>**

数据库定义了4个隔离级别：

 1. Serializable【可避免脏读，不可重复读，虚读】
 2. Repeatable read【可避免脏读，不可重复读】
 3. Read committed【可避免脏读】
 4. Read uncommitted【级别最低，什么都避免不了】
 
分别对应Connection类中的4个常量：

 1. TRANSACTION_READ_UNCOMMITTED
 2. TRANSACTION_READ_COMMITTED
 3. TRANSACTION_REPEATABLE_READ
 4. TRANSACTION_SERIALIZABLE
 
脏读：**一个事务读取到另外一个事务未提交的数据**

例子：A向B转账，**A执行了转妆语句，但A还没有提交事务，B读取数据，发现自己的账户钱表多了**！B给A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。

不可重复读：**一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改**

注：**A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】**

虚读(幻读)：**是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致**。

注：**和不可重复读类似，但虚读（幻读）会读到其他事务的插入的数据，导致前后读取不一致**

简单总结：脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定不行】。

数据库的乐观锁和悲观锁是什么？
====

确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，**乐观锁和悲观锁是并发控制主要采用的技术手段**。

* 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

    * **在查询数据的时候就把事务锁起来，直到提交事务**
    
    * 实现方式：使用数据库中的锁机制
    
* 乐观锁：假设不会发生并发冲突，只在提交操作是检查是否违法数据完整性。

    * **在修改数据的时候把事务锁起来，通过version的方式来进行锁定**
    
    * 实现方式：使用version版本或者时间戳
    
悲观锁：

```mysql
select * from eb_sku where sku_id = 1001 for update

update eb_skuset stock = 100-#{quantity} where sku_id = 1001
```

缺点：性能低

乐观锁：

```mysql
                sku_id                  stock               version

a(查询的数据)    1001                    100                 1
                1001                    98                  2

b(查询的数据)    1001                    100                 1
```

```java
select * from eb_sku where sku_id = 1001

update eb_sku set stock = 100-#{quantity}, version = #{version} + 1 where sku_id = #{skuId} and version = #{version} and stock >= #{quantity}
```

参考资料：

> * <a href="https://www.open-open.com/lib/view/open1452046967245.html">深入理解乐观锁与悲观锁</a>

超键、候选键、主键、外键分别是什么？
====

* 超键：**在关系中能唯一标识元组的属性集称为关系模式的超键**。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键，**超键包含候选键和主键**

* **候选键（候选码）**：**是最小超键，即没有冗余元素的超键**。

* **主键（主码）**：**数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合**。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

* **外键：在一个表中存在的另一个表的主键称此表的外键。**


**候选码和主码**：

例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）

* **它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}**

* **如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)**

SQL 约束有哪几种？
====

* NOT NULL: 用于控制字段的内容一定不能为空（NULL）。 

* UNIQUE: 控制字段内容不能重复，一个表允许有多个 Unique 约束。

* PRIMARY KEY: 也是用于控制字段内容不能重复，但它在一个表只允许出现一个。

* FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。

* CHECK: 用于控制字段的值范围。

数据库运行于哪种状态下可以防止数据的丢失？
====

**在archivelog mode(归档模式)只要其归档日志文件不丢失，就可以有效地防止数据丢失。**
