## 看在前面

- 轻量级锁（锁膨胀、锁自选、偏向锁、锁消除）：https://www.cnblogs.com/greengages/p/16620550.html
- java对象在内存中的结果（HotSpot虚拟机）：https://www.cnblogs.com/duanxz/p/4967042.html

一、乐观锁和悲观锁
====

悲观锁和乐观锁并不是某个具体的“锁”而是一种并发编程的基本概念。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包所引入。

> 悲观锁的历史到乐观锁的演进

悲观锁中互斥同步最主要的问题就是进行线程阻塞和唤醒锁带来的性能问题，因此这种同步也称为阻塞同步（Bklocking Synchronization）。从处理问题的方式上来说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一种选择：基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），这种乐观的并发策略的需要实现都不需要把线程挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronizeation）。
其中上述乐观锁并发策略需要“硬件指令集的发展”才能进行，是因为我们需要操作和检测这两个步骤具备原子性，靠什么来做保证呢？肯定是不能用互斥同步来保证，否则就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证从一个语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这种指令常用的有：
- 测试并设置，Test-and-Set
- 获取并增加，Fetch-and-Increment
- 交换，Swap
- Compare-and-Swap，简称CAS
- 加载链接/条件存储（Load-Linked/Store-Conditional，上文称LL/SC）

### 悲观锁

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。

### 乐观锁


乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。

二、公平锁和非公平锁
====

根据线程获取锁的抢占机制，锁又可以分为公平锁和非公平锁。

### 公平锁

公平锁是指多多个线程按照申请锁的顺序来获取锁。

### 非公平锁

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。ReentrantLock 提供了公平锁和非公平锁的实现。

* 公平锁：new ReentrantLock(true)

* 非公平锁：new ReentrantLock(false)

如果构造函数不传任何参数的时候，默认提供的是非公平锁。

三、独占锁和共享锁
====

根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁。

### 独占锁

独占锁是指任何时候都只有一个线程能执行资源操作。

### 共享锁

共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。比如 Java 中的 ReentrantReadWriteLock 就是共享锁的实现方式，它允许一个线程进行写操作，允许多个线程读操作。

ReentrantReadWriteLock 共享锁演示代码如下：

```java
public class ReadWriteLockTest {
    public static void main(String[] args) throws InterruptedException {
        final MyReadWriteLock rwLock = new MyReadWriteLock();
        // 创建读锁 r1 和 r2
        Thread r1 = new Thread(new Runnable() {
            @Override
            public void run() {
                rwLock.read();
            }
        }, "r1");
        Thread r2 = new Thread(new Runnable() {
            @Override
            public void run() {
                rwLock.read();
            }
        }, "r2");
        r1.start();
        r2.start();
        // 等待同时读取线程执行完成
        r1.join();
        r2.join();
        // 开启写锁的操作
        new Thread(new Runnable() {
            @Override
            public void run() {
                rwLock.write();
            }
        }, "w1").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                rwLock.write();
            }
        }, "w2").start();
    }
    static class MyReadWriteLock {
        ReadWriteLock lock = new ReentrantReadWriteLock();
        public void read() {
            try {
                lock.readLock().lock();
                System.out.println("读操作，进入 | 线程：" + Thread.currentThread().getName());
                Thread.sleep(3000);
                System.out.println("读操作，退出 | 线程：" + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.readLock().unlock();
            }
        }
        public void write() {
            try {
                lock.writeLock().lock();
                System.out.println("写操作，进入 | 线程：" + Thread.currentThread().getName());
                Thread.sleep(3000);
                System.out.println("写操作，退出 | 线程：" + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.writeLock().unlock();
            }
        }
    }
}
```

以上程序执行结果如下：

```java
读操作，进入 | 线程：r1
读操作，进入 | 线程：r2
读操作，退出 | 线程：r1
读操作，退出 | 线程：r2
写操作，进入 | 线程：w1
写操作，退出 | 线程：w1
写操作，进入 | 线程：w2
写操作，退出 | 线程：w2
```

四、可重入锁
====

可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。

五、偏向锁 & 轻量级锁 & 重量级锁
====

### 5.1 偏向锁

偏向锁也是JDK1.6中引入的一项锁优化，它的目的是消除在无精症情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。
偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数 -XX:-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。
偏向锁的偏向过程

偏向锁的“偏”，就是偏心的”偏“、偏袒的”偏“，它的意思是这个锁会偏向于第一个获得他的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。参照轻量级锁中关于对象头Mark Word与线程之间的操作过程，那偏向锁的原理理解起来就很简单了。假设当前虚拟机启动了偏向锁（启用参数-XX:UseBiasedLocking，这是JDK1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking、Unlocking以及对Mark Word的Update等）。
当有另外一个线程区尝试获取这个锁时，偏向模式就宣告结束了。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为”01“）或轻量级锁定（标志位为”00“）的状态，后续的同步操作就转到轻量级锁那样执行。偏向锁、轻量级锁的状态转换以及对象Mark Word的关系如下图所示：
图片待补充

### 5.2 轻量级锁

首先强调一点：轻量级锁并不是同来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。要理解轻量级锁，以及偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象（对象头部分）的内存布局开始了解。
轻量级锁能提升程序同步性能的依据是“对于绝大部份的锁，在整个同步周期内都是不存在竞争的”，这是个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

> 轻量级锁加锁和解锁过程

轻量级锁加锁过程

在代码进入同步块的时候，如果此对象没有被锁定（锁标志为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝家了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示：
图片待补充
然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示：
图片待补充
如果这个更新操作失败了（失败的原因是因为同时存在多个线程获取临界区资源），虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

轻量级锁解锁过程

轻量级锁的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了，如果替换失败（之所以会替换失败，是因为锁升级为重量级锁了），说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

### 5.3 重量级锁

详见：

### 5.4 偏向锁、轻量级锁、重量级锁的升级过程

偏向锁、轻量级锁、重量级锁

![image](https://github.com/Mein-Augenstern/MUYI/assets/34135120/46ddb54d-9f78-407c-ae80-6cf2d6229f20)

偏向锁Biased Locking：Java6引入的一项多线程优化，偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。 

自旋锁：自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。一直在自旋也是占用CPU的，如果自旋的线程非常多，自旋次数也非常大CPU可能会跑满，所以需要升级。

重量级锁：内核态的锁，资源开销较大。内部会将等待中的线程进行wait处理，防止消耗CPU。

六、CAS与ABA
====

### 自旋CAS

自旋是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。

> 自旋锁的优缺点 -GPT3.5

自旋是一种基于忙等待的锁机制，在某些情况下可以提供比传统的阻塞锁更好的性能。然而，自旋也存在一些缺点。下面是自旋锁的优缺点：

优点：

1. 低延迟：线程不会被挂起和唤醒，与阻塞锁相比，自旋锁不需要线程在临界区外被挂起和唤醒的开销，避免了线程上下文切换的开销，可以提供更低的延迟。
2. 线程等待时间短：自旋锁适用于临界区的代码执行时间非常短暂的情况，如果线程只需要等待一小段时间就能获取到锁，那么自旋锁可以避免线程进入阻塞状态，提高效率。
3. 避免阻塞的开销：自旋锁适用于多核CPU的情况，当一个线程在自旋锁上自旋等待时，其他线程可以继续执行，不会被阻塞。这样可以充分利用多核CPU的处理能力，提高并发性能。
   
缺点：

1. 占用CPU资源：自旋锁需要线程在临界区上进行忙等待，会占用CPU资源，如果临界区的代码执行时间较长，或者自旋等待的时间过长，会导致自旋锁白白浪费了CPU资源。
2. 无法解决真正的竞争：如果临界区的锁竞争很激烈，多个线程同时自旋等待获取锁，会导致大量的CPU时间被浪费在自旋等待上，而且无法保证获取锁的顺序，可能会出现饥饿现象。
3. 只适用于多核CPU：自旋锁是通过线程自旋等待的方式来实现的，只有在多核CPU的情况下才能发挥其优势。在单核CPU的情况下，自旋等待不会释放CPU资源，可能会导致其他线程无法执行。
   
综上所述，自旋锁适用于临界区执行时间短暂、锁竞争不激烈、多核CPU的场景，可以提供较低的延迟和高并发性能。但在临界区执行时间较长、锁竞争激烈、单核CPU的情况下，自旋锁可能会导致CPU资源的浪费和性能下降。因此，在选择使用自旋锁时需要根据具体的场景和需求进行权衡和评估。

```java
import java.util.concurrent.atomic.AtomicBoolean;

public class SpinLock {
    private AtomicBoolean locked = new AtomicBoolean(false);

    public void lock() {
        // 自旋等待直到成功获取锁
        while (!locked.compareAndSet(false, true)) {
            // 自旋等待
        }
    }

    public void unlock() {
        locked.set(false);
    }
}
```

> 自适应自旋

来自深入了解Java虚拟机

自适应自旋以为这自旋的事件不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而他将允许自旋等待持续相对更长的时间，如果100个玄幻。另外，对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得变来越“聪明”了。

来自GPT3.5

自适应自旋（Adaptive Spinning）是一种对自旋锁进行优化的技术，旨在提高自旋锁的性能和效率。它基于运行时的动态信息和硬件特性，通过监控和调整自旋等待的策略，以适应当前的运行环境和线程行为。
自适应自旋的背景是，传统的自旋锁在多线程竞争激烈的情况下，可能会导致大量的线程进行自旋等待，从而浪费了CPU资源。而且，自旋等待的时间长短对性能有很大的影响，在临界区执行时间短暂时，自旋等待可以提供较低的延迟；但在临界区执行时间较长时，自旋等待可能会浪费大量的CPU时间。
因此，自适应自旋的目标是通过动态地调整自旋等待的策略，以在不同情况下获得更好的性能。它可以根据运行时的数据和硬件特性做出智能决策，包括自旋等待的次数、自旋等待的时间、线程是否挂起等。它可以根据实际情况选择合适的自旋等待策略，并在运行时进行调整，以提高系统的并发性能。
自适应自旋可以解决以下问题：

1. 线程饥饿问题：传统的自旋锁可能会导致某些线程长时间无法获取到锁，称为线程饥饿。通过自适应自旋，可以根据线程的等待情况和锁的竞争情况，调整自旋等待的策略，避免线程饥饿问题的发生。
2. CPU资源浪费问题：传统的自旋锁会导致大量的线程进行自旋等待，占用了大量的CPU资源。自适应自旋可以根据实际情况决定是否进行自旋等待，以避免CPU资源的浪费。
3. 延迟问题：传统的自旋锁在临界区执行时间短暂时可以提供较低的延迟，但在临界区执行时间较长时可能会浪费大量的CPU时间。自适应自旋可以根据实际情况调整自旋等待的时间，以平衡延迟和CPU资源的消耗。
   
综上所述，自适应自旋通过动态地调整自旋等待的策略，根据实际情况和硬件特性做出智能决策，可以提高自旋锁的性能和效率，并解决线程饥饿、CPU资源浪费和延迟等问题。

CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中 java.util.concurrent 包下的 AtomicInteger 就是借助 CAS 来实现的。

但 CAS 也不是没有任何副作用，比如著名的 ABA 问题就是 CAS 引起的。

### ABA 问题描述

老王去银行取钱，余额有 200 元，老王取 100 元，但因为程序的问题，启动了两个线程，线程一和线程二进行比对扣款，线程一获取原本有 200 元，扣除 100 元，余额等于 100 元，此时阿里给老王转账 100 元，于是启动了线程三抢先在线程二之前执行了转账操作，把 100 元又变成了 200 元，而此时线程二对比自己事先拿到的 200 元和此时经过改动的 200 元值一样，就进行了减法操作，把余额又变成了 100 元。这显然不是我们要的正确结果，我们想要的结果是余额减少了 100 元，又增加了 100 元，余额还是 200 元，而此时余额变成了 100 元，显然有悖常理，这就是著名的 ABA 的问题。

执行流程如下:

* 取款线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。

* 取款线程二：取款，获取原值 200 元，阻塞等待修改。

* 转账线程一：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。

* 取款线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。

最终的结果是 100 元。

### ABA 问题的解决

常见解决 ABA 问题的方案加版本号，来区分值是否有变动。以老王取钱的例子为例，如果加上版本号，执行流程如下。

* 取款线程一：取款，获取原值 200_V1，与 200_V1 比对成功，减去 100 元，修改结果为 100_V2。

* 取款线程二：取款，获取原值 200_V1 阻塞等待修改。

* 转账线程一：转账，获取原值 100_V2，与 100_V2 对比成功，加 100 元，修改结果为 200_V3。

* 取款线程二：取款，恢复执行，原值 200_V1 与现值 200_V3 对比不相等，退出修改。

最终的结果为 200 元，这显然是我们需要的结果。

在程序中，要怎么解决 ABA 的问题呢？

在 JDK 1.5 的时候，Java 提供了一个 AtomicStampedReference 原子引用变量，通过添加版本号来解决 ABA 的问题，具体使用示例如下：

```java
String name = "老王";
String newName = "Java";
AtomicStampedReference<String> as = new AtomicStampedReference<String>(name, 1);
System.out.println("值：" + as.getReference() + " | Stamp：" + as.getStamp());
as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + 1);
System.out.println("值：" + as.getReference() + " | Stamp：" + as.getStamp());
```

以上程序执行结果如下：

```java
值：老王 | Stamp：1
值：Java | Stamp：2
```



