## 文章来源

1、深入分析 java 8 编程语言规范：Threads and Locks：https://javadoop.com/post/Threads-And-Locks-md

在 java 并发编程中，线程和锁永远是最重要的概念。语言规范虽然是规范描述，但是其中也有非常多的知识和最佳实践是值得学习的，相信这篇文章还是可以给很多读者提供学习参考的。

本文主要是翻译 + 解释 Oracle《The Java Language Specification, Java SE 8 Edition》（https://docs.oracle.com/javase/specs/index.html ）的第17章《Threads and Locks》（https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html ），原文大概30页pdf，我加入了很多自己的理解，希望能帮大家把规范看懂，并且从中得到很多你一直想要知道但是还不知道的知识。

注意，本文在说 Java 语言规范，不是 JVM 规范，JVM 的实现需要满足语言规范中定义的内容，但是具体的实现细节由各 JVM 厂商自己来决定。所以，语言规范要尽可能严谨全面，但是也不能限制过多，不然会限制 JVM 厂商对很多细节进行性能优化。

我能力有限，虽然已经很用心了，但有些地方我真的不懂，我已经在文中标记出来了。

建议分 3 部分阅读。

- 将 17.1、17.2、17.3 一起阅读，这里关于线程中的 wait、notify、中断有很多的知识；

- 17.4 的内存模型比较长，重排序和 happens-before 关系是重点；

- 剩下的 final、字分裂、double和long的非原子问题，这些都是相对独立的 topic。

## Chapter 17. Threads and Locks

### 前言

在 java 中，线程由 Thread 类表示，用户创建线程的唯一方式是创建 Thread 类的一个实例，每一个线程都和这样的一个实例关联。在相应的 Thread 实例上调用 start() 方法将启动一个线程。

如果没有正确使用同步，线程表现出来的现象将会是令人疑惑的、违反直觉的。这个章节将描述多线程编程的语义问题，包括一系列的规则，这些规则定义了在多线程环境中线程对共享内存中值的修改是否对其他线程立即可见。java编程语言内存模型定义了统一的内存模型用于屏蔽不同的硬件架构，在没有歧义的情况下，下面将用内存模型表示这个概念。

这些语义没有规定多线程的程序在 JVM 的实现上应该怎么执行，而是限定了一系列规则，由 JVM 厂商来满足这些规则，即不管 JVM 的执行策略是什么，表现出来的行为必须是可被接受的。

> 操作系统有自己的内存模型，C/C++ 这些语言直接使用的就是操作系统的内存模型，而 Java 为了屏蔽各个系统的差异，定义了自己的统一的内存模型。
> 简单说，Java 开发者不再关心每个 CPU 核心有自己的内存，然后共享主内存。而是把关注点转移到：每个线程都有自己的工作内存，所有线程共享主内存。
