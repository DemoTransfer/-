> * 控制反转（Inversion of Control，英文缩写为IoC）

> * 面向切面编程（Aspect Oriented Programming，英文缩写为AOP）

我们是在使用```Spring```框架的过程中，很大一部分是为了使用```IoC(依赖注入)```和```AOP(面向切面编程)```，这两个是```Spring```的灵魂。其中主要用到的设计模式有工厂模式和代理模式。```IoC```就是典型的工厂模式，通过```sessionfactory```去注入实例。```AOP```就是典型的代理模式的体现。```Spring```的```IoC```容器是```Spring```的核心，```Spring AOP```是```Spring```框架的重要组成部分。

关于IoC
====

首先想说说```IoC（Inversion of Control，控制倒转）```。这是```Spring```的核心，贯穿始终。所谓```IoC```，对于```Spring```框架来说，就是由```Spring```来负责控制对象的生命周期和对象间的关系。

这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己```new```一个，或者从```JNDI```中查询一个），使用完之后还要将对象销毁（比如```Connection```等），对象始终会和其他的接口或类藕合起来。

那么```IoC```是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。```Spring```所倡导的开发方式就是如此，所有的类都会在```Spring```容器中登记，告诉```Spring```你是个什么东西，你需要什么东西，然后```Spring```会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由```Spring```来控制，也就是说控制对象生存周期的不再是引用它的对象，而是```Spring```。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被```Spring```控制，所以这叫控制反转。如果你还不明白的话，我决定放弃。

```IoC```的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过```DI（Dependency
Injection，依赖注入）```来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个```Connection```对象，有了```Spring```我们就只需要告诉```Spring```，A中需要一个```Connection```，至于这个```Connection```怎么构造，何时构造，A不需要知道。在系统运行时，```Spring```会在适当的时候制造一个```Connection```，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。

A需要依赖```Connection```才能正常运行，而这个```Connection```是由```Spring```注入到A中的，依赖注入的名字就这么来的。那么```DI```是如何实现的呢？ Java1.3之后一个重要特征是```反射（reflection）```，它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，```Spring```就是通过反射来实现注入的。关于反射的相关资料请查阅java doc。

**<h3>小结</h3>**

```IoC```:控制反转也叫依赖注入。利用了工厂模式将对象交给容器管理，你只需要在```Spring```配置文件总配置相应的```bean```，以及设置相关的属性，让````Spring```容器来生成类的实例对象以及管理对象。在```Spring```容器启动的时候，```Spring```会把你在配置文件中配置的```bean```都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些```bean```分配给你需要调用这些```bean```的类（假设这个类名是A），分配的方法就是调用A的```setter```方法来注入，而不需要你在A里面```new```这些```bean```了。

-----

关于代理模式
====

<a href="https://github.com/DemoTransfer/demotransfer/tree/master/pattern/proxy">常见代理模式示例代码</a>

代理模式是常用的```Java```设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在```Spring```里创建被调用者的工作不再由调用者来完成，因此```控制反转（IoC）```；创建被调用者实例的工作通常由```Spring```容器来完成，然后注入调用者，因此也被称为依赖注入```（DI）```，依赖注入和控制反转是同一个概念。

------

关于AOP
====

面向方面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。```Spring AOP``` 只实现了方法级别的连接点，在J2EE应用中，```AOP```拦截到方法级别的操作就已经足够。在```Spring```中，未来使```IOC```方便地使用健壮、灵活的企业服务，需要利用```Spring AOP```实现为```IOC```和企业服务之间建立联系。

面向切面编程```AOP```可以说是对```OOP```的补充和完善。```OOP```引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，```OOP```则显得无能为力。也就是说，```OOP```允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在```OOP```设计中，它导致了大量代码的重复，而不利于各个模块的重用。将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。

实现```AOP```的技术，主要分为两大类：一是采用**动态代理技术**，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用**静态织入的方式**，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码.简单点解释，比方说你想在你的biz层所有类中都加上一个打印‘你好’的功能,这时就可以用**AOP**思想来做.你先写个类写个类方法，方法经实现打印‘你好’,然后```IoC```这个类 ```ref＝“biz.*”```让每个类都注入即可实现。

------

关于工厂模式
====

<a href="https://github.com/DemoTransfer/demotransfer/tree/master/pattern/factory">常见工厂模式示例代码</a>

