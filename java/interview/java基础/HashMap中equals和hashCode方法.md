看在前面
====

> 作者：敖丙
链接：https://juejin.im/post/5dee6f54f265da33ba5a79c8
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Question
====

为啥我们重写equals方法的时候需要重写hashCode方法呢？用HashMap举个例子？

这都能被他问到，还好我看了敖丙的系列呀，不然真的完了！！！

但是我想拖延点时间，只能故做沉思，仰望天空片刻，45°仰望天空的样子，说实话，我看到面试官都流口水了！可惜我是他永远得不到的男人，好了不装逼了。

我想起来了面试官！

因为在java中，所有的对象都是继承于Object类。Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。
在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址，显然我们new了2个对象内存地址肯定不一样

* 对于值对象，==比较的是两个对象的值

* 对于引用对象，比较的是两个对象的地址

大家是否还记得我说的HashMap是通过key的hashCode去寻找index的，那index一样就形成链表了，也就是说”帅丙“和”丙帅“的index都可能是2，在一个链表上的。
我们去get的时候，他就是根据key去hash然后计算出index，找到了2，那我怎么找到具体的”帅丙“还是”丙帅“呢？

equals！是的，所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。
不然一个链表的对象，你哪里知道你要找的是哪个，到时候发现hashCode都一样，这不是完犊子嘛。

