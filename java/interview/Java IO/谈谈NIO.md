看在前面
====

* <a href="https://gitbook.cn/books/5b1792ad26a49a55324e782c/index.html">谈谈 Java NIO</a>

> 原创作者信息：应书澜

> 毕业于 C9 高校，硕士学历，曾在 IEEE ITS、VSD 等 Top 期刊发表论文。多年研发经验，精通 Java、Python 及 C 语言，擅长预测算法，分布式中间件；曾在华为、阿里巴巴，上海电气等公司重要项目中担任技术负责人或核心研发成员，现专注于中间件技术，同时长期负责招聘。

> 原创作者GitChat主页：<a href="https://gitbook.cn/gitchat/author/5a98122bfdc2050df046d997">应书澜</a>

> 目前正在联系GitChat获取转载权限，若有权限，立马删除^^。

在 JDK1.4 之后，为了提高 Java IO 的效率，Java 提供了一套 New IO (NIO)，之所以称之为 New，原因在于它相对于之前的 IO 类库是新增的。此外，旧的 IO 类库提供的 IO 方法是阻塞的，New IO 类库则让 Java 可支持非阻塞 IO，所以，更多的人喜欢称之为非阻塞 IO（Non-blocking IO）。

NIO 应用非常广泛，是 Java 进阶的必学知识，此外，在 Java 相关岗位的面试中也是“常客”，对于准备深入学习 Java 的读者，了解 NIO 确有必要。

Question
====

* IO 与 NIO 有何不同？
* NIO 核心对象 Buffer 详解；
* NIO 核心对象 Channel 详解；
* NIO 核心对象 Selector 详解；
* Reactor 模式介绍。

1 IO 和 NIO 相关的预备知识
====

1.1 IO 的含义
------

讲 NIO 之前，我们先来看一下 IO。

Java IO 即 Java 输入输出。在开发应用软件时，很多时候都需要和各种输入输出相关的媒介打交道。与媒介进行 IO 操作的过程十分复杂，需要考虑众多因素，比如：进行 IO 操作**媒介的类型**（文件、控制台、网络）、**通信方式**（顺序、随机、二进制、按字符、按字、按行等等）。

Java 类库提供了相应的类来解决这些难题，这些类就位于 java.io 包中， 在整个 java.io 包中最重要的就是 5 个类和一个接口。5 个类指的是 ```File```、```OutputStream```、```InputStream```、```Writer```、```Reader```；一个接口指的是 ```Serializable```。

由于老的 Java IO 标准类提供 IO 操作（如 ```read()```，```write()```）都是同步阻塞的，因此，IO 通常也被称为阻塞 IO（即 BIO，```Blocking I/O```）。

1.2 NIO 含义
------

在 JDK1.4 之后，为了提高 Java IO 的效率，Java 又提供了一套 New IO（NIO），原因在于它相对于之前的 IO 类库是新增的。此外，旧的 IO 类库提供的 IO 方法是阻塞的，New IO 类库则让 Java 可支持非阻塞 IO，所以，更多的人喜欢称之为非阻塞 IO（Non-blocking IO）。

1.3 四种 IO 模型
------

**同步阻塞 IO：**

在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。 Java 传统的 IO 模型属于此种方式！ 

**同步非阻塞 IO：**

在此种方式下，用户进程发起一个 IO 操作以后 便可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 Java 的 NIO 就属于同步非阻塞 IO 。 

**异步阻塞 IO：**

此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！ 

**异步非阻塞 IO：**

在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为 真正的 IO 读取或者写入操作已经由 内核完成了。目前 Java 中还没有支持此种 IO 模型。

1.4 小结
------

所有的系统 I/O 都分为两个阶段：**等待就绪和操作**。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。Java IO 的各种流是阻塞的。这意味着当线程调用 write() 或 read() 时，线程会被阻塞，直到有一些数据可用于读取或数据被完全写入。

需要说明的是等待就绪引起的 “阻塞” 是不使用 CPU 的，是在 “空等”；而真正的读写操作引起的“阻塞” 是使用 CPU 的，是真正在”干活”，而且这个过程非常快，属于 memory copy，带宽通常在 1GB/s 级别以上，可以理解为基本不耗时。因此，所谓 “阻塞” 主要是指等待就绪的过程。

**以socket.read()为例子：**

传统的阻塞 IO(BIO) 里面 socket.read()，如果接收缓冲区里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。

而对于非阻塞 IO(NIO)，如果接收缓冲区没有数据，则直接返回 0，而不会阻塞；如果接收缓冲区有数据，就把数据从网卡读到内存，并且返回给用户。

说得接地气一点，BIO 里用户最关心 “我要读”，NIO 里用户最关心” 我可以读了”。NIO 一个重要的特点是：socket 主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的 I/O 操作是同步阻塞的（消耗 CPU 但性能非常高）。

